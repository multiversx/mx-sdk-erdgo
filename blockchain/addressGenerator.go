package blockchain

import (
	"bytes"
	"encoding/binary"

	elrondCore "github.com/ElrondNetwork/elrond-go-core/core"
	"github.com/ElrondNetwork/elrond-go-core/core/check"
	"github.com/ElrondNetwork/elrond-go-core/hashing"
	"github.com/ElrondNetwork/elrond-go-core/hashing/keccak"
	"github.com/ElrondNetwork/elrond-go/process"
	"github.com/ElrondNetwork/elrond-go/process/factory"
	"github.com/ElrondNetwork/elrond-sdk-erdgo/core"
	"github.com/ElrondNetwork/elrond-sdk-erdgo/data"
)

const accountStartNonce = uint64(0)

var initialDNSAddress = bytes.Repeat([]byte{1}, 32)

// ArgsAddressGenerator represents the arguments structure for the address generator
type ArgsAddressGenerator struct {
	PubkeyConv  elrondCore.PubkeyConverter
	Coordinator *shardCoordinator
}

// addressGenerator is used to generate some addresses based on elrond-go logic
type addressGenerator struct {
	coordinator *shardCoordinator
	pubkeyConv  elrondCore.PubkeyConverter
	hasher      hashing.Hasher
}

// NewAddressGenerator will create an address generator instance
func NewAddressGenerator(args ArgsAddressGenerator) (*addressGenerator, error) {
	if check.IfNil(args.Coordinator) {
		return nil, ErrNilShardCoordinator
	}
	if check.IfNil(args.PubkeyConv) {
		return nil, process.ErrNilPubkeyConverter
	}

	return &addressGenerator{
		coordinator: args.Coordinator,
		pubkeyConv:  args.PubkeyConv,
		hasher:      keccak.NewKeccak(),
	}, nil
}

// CompatibleDNSAddress will return the compatible DNS address providing the shard ID
func (ag *addressGenerator) CompatibleDNSAddress(shardId byte) (core.AddressHandler, error) {
	addressLen := len(initialDNSAddress)
	shardInBytes := []byte{0, shardId}

	newDNSPk := string(initialDNSAddress[:(addressLen-elrondCore.ShardIdentiferLen)]) + string(shardInBytes)
	newDNSAddress, err := ag.NewAddress([]byte(newDNSPk), accountStartNonce, factory.ArwenVirtualMachine)
	if err != nil {
		return nil, err
	}

	return data.NewAddressFromBytes(newDNSAddress), err
}

// CompatibleDNSAddressFromUsername will return the compatible DNS address providing the username
func (ag *addressGenerator) CompatibleDNSAddressFromUsername(username string) (core.AddressHandler, error) {
	hash := ag.hasher.Compute(username)
	lastByte := hash[len(hash)-1]
	return ag.CompatibleDNSAddress(lastByte)
}

// ComputeArwenScAddress will return the smart contract address that will be generated by the Arwen VM providing
// the owner's address & nonce
func (ag *addressGenerator) ComputeArwenScAddress(address core.AddressHandler, nonce uint64) (core.AddressHandler, error) {
	if check.IfNil(address) {
		return nil, ErrNilAddress
	}

	scAddressBytes, err := ag.NewAddress(address.AddressBytes(), nonce, factory.ArwenVirtualMachine)
	if err != nil {
		return nil, err
	}

	return data.NewAddressFromBytes(scAddressBytes), nil
}

// NewAddress is a hook which creates a new smart contract address from the creators address and nonce
// The address is created by applied keccak256 on the appended value off creator address and nonce
// Prefix mask is applied for first 8 bytes 0, and for bytes 9-10 - VM type
// Suffix mask is applied - last 2 bytes are for the shard ID - mask is applied as suffix mask
func (ag *addressGenerator) NewAddress(creatorAddress []byte, creatorNonce uint64, vmType []byte) ([]byte, error) {
	addressLength := ag.pubkeyConv.Len()
	if len(creatorAddress) != addressLength {
		return nil, ErrAddressLengthNotCorrect
	}

	if len(vmType) != elrondCore.VMTypeLen {
		return nil, ErrVMTypeLengthIsNotCorrect
	}

	base := hashFromAddressAndNonce(creatorAddress, creatorNonce)
	prefixMask := createPrefixMask(vmType)
	suffixMask := createSuffixMask(creatorAddress)

	copy(base[:elrondCore.NumInitCharactersForScAddress], prefixMask)
	copy(base[len(base)-elrondCore.ShardIdentiferLen:], suffixMask)

	return base, nil
}

func hashFromAddressAndNonce(creatorAddress []byte, creatorNonce uint64) []byte {
	buffNonce := make([]byte, 8)
	binary.LittleEndian.PutUint64(buffNonce, creatorNonce)
	adrAndNonce := append(creatorAddress, buffNonce...)
	scAddress := keccak.NewKeccak().Compute(string(adrAndNonce))

	return scAddress
}

func createPrefixMask(vmType []byte) []byte {
	prefixMask := make([]byte, elrondCore.NumInitCharactersForScAddress-elrondCore.VMTypeLen)
	prefixMask = append(prefixMask, vmType...)

	return prefixMask
}

func createSuffixMask(creatorAddress []byte) []byte {
	return creatorAddress[len(creatorAddress)-2:]
}
